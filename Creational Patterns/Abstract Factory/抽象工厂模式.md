# 抽象工厂模式

Reference：https://refactoringguru.cn/design-patterns/abstract-factory

> 创建一系列相关的对象，而无需指定其具体类

## 实际情境对应

- 场景：生产一系列多风格的产品
- 现状：定义了相应的类来生成不同风格的系列产品
- 需要解决的问题：
  - 需要能够单独生成每件家具对象，保证风格一致
  - 方便添加新的风格和产品

## 解决方案-抽象工厂

- 根据产品的种类确定接口数量，有多少种系列产品就有多少接口，产品变体实现接口（E.g.：定义沙发接口，多种风格的沙发都实现沙发接口）
- 工厂可以生产产品，将同种风格的产品承包给一家工厂去做，有多少种风格就有多少种厂家，每个厂家生产同种风格的不同系列产品（E.g.：定义抽象工厂接口，多种风格的工厂都实现公共工厂接口）
- 在客户端通过相应的接口调用工厂类和产品类。

**测试：** 客户不知道什么工厂类，也不知道什么椅子的风格，只想要一把椅子，对待不同风格的椅子客户一视同仁，所以客户直接与椅子抽象接口产生关系，通过这个接口去与工厂类和产品类之间建立间接关系。

## 深入了解抽象工厂模式结构

![抽象工厂设计模式](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure.png?id=30a2415c54a4b9bab844)

## 适用场景

### 设计时发现在无法提前获取信息的条件下，需要与多个不同系列的产品交互，另一方面也为了扩展性，则使用抽象工厂

抽象工厂提供一个接口，可以用于创建每个系列产品的对象，主要代码通过该接口创建对象，那就一定不会生成与应用程序已生产的产品类型不一致的产品。

### 当有一个基于一组抽象方法的类，且主要功能不明确，可以使用抽象工厂

设计良好的程序中，每个类仅负责一件事，如果一个类与多种类型产品交互，就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

## 优缺点

**优点：**

- 确保同一工厂生成的产品相互匹配
- 解耦客户端和具体产品
- 单一职责，将产品生成的代码抽取出来，易于维护
- 开闭原则，向应用程序中引入新产品变体时，无需修改客户端代码

**缺点：** 需要引入较多的接口和类，代码较为复杂。