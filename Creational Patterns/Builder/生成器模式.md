# 生成器模式

Reference：https://refactoringguru.cn/design-patterns/builder

> 分步创建复杂对象，使用相同的创建代码生成不同类型和形式的对象。

## 实际情境对应

> 对象的复杂性造成构造函数过于复杂

- 场景：通过构造函数创建房屋对象
- 现状：将多个房屋附带设备，房屋风格等一系列信息作为构造函数的参数，为参数赋不同的值最终创建不同的房屋对象
- 遇到的问题：
  - 每次创建房屋对象都需要传入多个参数，可能这些参数本就没有必要都传
  - 如果增加了一个房屋参数，那么之前的创建方法都得改变

## 解决方案-生成器模式

将构造构成划分为一组步骤，原本构造函数传入多个参数划分为多个创建步骤，通过执行一系列需要的创建步骤，省去了不必要的创建步骤。

每一次创建步骤都去返回生成器对象，就可以实现不断地创建。

### 深入生成器模式结构

> 将对象构造代码从产品中抽取出来，并放在一个生成器的独立对象中。生成器能够分步创建复杂对象，在创建过程中不允许其他对象访问。

![生成器设计模式结构](https://refactoringguru.cn/images/patterns/diagrams/builder/structure.png)

几点特意说明：

- 生成器接口声明通用的产品构造步骤
- 具体生成器可遵守也可不遵守通用步骤
- 主管（Director）可以定义构造的步骤，在创建的时候更加便于复用

### 适用场景

### 避免重复构造函数

假如构造函数中有多个可选参数，调用时较不方便，所以通过重载的方式新建几个只有较少参数的简化版，但是这些重载的构造函数仍然需要主构造函数，传递一些默认的数值来替代省略掉的参数。

这种做法也只适合一些支持重载的编程语言，通过生成器可以分步骤生成对象，允许仅使用必须的步骤。

### 希望创建不同形式的产品时

即生成器结构中提到的：

1. 基本生成器接口中定义了所有可能的制造步骤
2. 具体生成器将实现这些步骤来制造特定的产品
3. 主管类将负责管理制造步骤的顺序。

### 使用生成器构造组合树或其他负责对象

- 生成器模式可以分步构造，可以延迟或者递归执行某些创建步骤，但是不影响最终的产品
- 在制造步骤的过程中，不能对外发布未完成的产品，可以避免被其他代码获取到不完整的对象的情况。

### 优缺点

**优点：** 

- 分步创建对象，暂缓创建步骤或递归运行创建步骤
- 生成不同形式的产品时，复用相同的制造代码
- 单一职责原则，可以将复杂构造代码从产品的业务逻辑中分离出来

**缺点：** 增加多个类，整体复杂度增加
