# 工厂方法模式

Reference：https://refactoringguru.cn/design-patterns/factory-method

> **父类**中提供一个创建对象的**方法**，允许**子类决定**实例化对象的类型

## 实际情境对应

- 场景：开发一款物流管理应用
- 当前状况：由于应用的最初版本只能处理卡车运输，为了快捷开发，只创建了一个卡车类
- 遇到的问题：业务逐渐庞大，需要处理的功能越来越多，使用方的请求越来越多，包括不仅仅陆地上的运输方式。如果单纯创建新的类以应对不同的需求，你会发现自己不断地复写代码，copy and paste… ⊙﹏⊙

## 解决方案-工厂方法

**看透本质：**

1. 用特殊的工厂方法代替对象构造函数
2. 其实还是通过new运算符创建对象
3. 调用的位置不同，不在子类中调用，转而放在工厂方法中去调用（改变了new行为的位置，就可以在子类中重写工厂方法，也就可以创建任意想要的类型）

**应用到实际情境：**

1. 抽取出来一个运输类，并在基类中实现一个创建对象的工厂方法，所有的运输方法都来实现这个基类，重写工厂方法，改变返回的类型。

![创建者类结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution1.png)

2. 为了得到我们想要的返回类型，还有一个要求，这些我们期待得到的多个返回类型必须具有共同的基类或者接口，同时在运输类的工厂方法中应该将其返回类型声明为这个基类或者接口。

3. 抽取出来一个运输接口，并在这个公共的接口中声明一个交付货物的方法，所有的运输工具都来实现这个接口（E.g.：卡车走陆路交付货物，轮船走海路交付货物）

![产品对象层次结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution2-zh.png)

总结：调用工厂方法的代码（客户端代码）不需要了解子类返回实际对象之间的差别。所有的运输工具Trunk、Ship etc.在客户端看来都是抽象的运输Transport。

## 深入了解工厂方法模式的结构

![工厂方法模式结构](https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure.png)

将上边两个实际应用的结构结合起来，就是工厂方法模式的结构。

具体创建者（ConcreteCreatorA，ConcreteCreatorB）重写了基础工厂方法，返回不同类型的产品，但并不是每一次调用工厂方法都会创建新的实例，因为工厂方法也可以返回缓存、对象池或其他来源的已有对象。

创建者类（Creator）中声明了返回产品对象的工厂方法，可以把工厂方法声明为抽象方法，或者在基础工厂方法中返回默认的基础产品类型。需要注意的是，我们在实际应用场景中也提到了，创建者类其实并不是主要用来创建的，做的更多的是逻辑处理的工作。在创建者类中通常包含一些与产品相关的核心业务逻辑，利用工厂方法将这些逻辑从具体产品类中分离出来。（E.g.：大型软件开发公司拥有程序员培训部门，但是公司的主要工作并不是生产程序员，而是编程）

## 适用场景

### 无法预知对象的确切的类别以及依赖关系的时候，可以使用工厂方法来编写代码

这种模式将创建产品和使用产品的两部分代码分离开来，解耦并且便于扩展，要添加新的产品，直接写一个新的创建者子类，并重写创建者类的工厂方法。

### 如果要实现一套软件库或者某一个框架的内部组件，遵循开闭原则，给更多的人扩展的机会，就可以使用工厂方法

把各框架中的创建组件的代码集中到单个工厂方法中。

E.g.：有一个场景，开发UI的时候经常使用第三方框架，如果原生框架支持的是矩形按钮，我们要用的是圆形按钮。

创建圆形按钮类（ProductA）继承按钮类（Product），根据基础框架类（Creator）开发子类圆形按钮UI类（ConcreteCreatorA），重写创建按钮的方法（CreateProduct），基础框架类中返回的是按钮对象，而圆形按钮UI类返回的是圆形按钮对象。

### 如果希望通过复用对象来节省系统资源，而不是每次重新创建对象，可以使用工厂方法

在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时，会经常需要我们做复用，优先使用对象池中可用的对象，再创建新的对象。

将创建存储空间，搜索可用对象，对象返回，创建新对象这四步放在重用的对象类构造函数中。

## 优缺点

**优点：**

- 将具体产品和创建者之间解耦
- 单一职责，产品创建代码放在一起，便于维护
- 开闭原则，支持新产品的引入

**缺点：** 通过结构可以看得出来需要引入较多的子类，不过尽量把这个结构嵌入现有的层次结构