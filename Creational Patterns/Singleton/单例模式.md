# 单例模式

Reference：https://refactoringguru.cn/design-patterns/singleton

> 保证一个类只有一个实例，并提供一个访问该实例的全局节点

事实上，单例模式并不符合单一职责原则，因为其同时解决了两个问题：

1. 保证一个类只有一个实例
   - 控制实例数量通常体现在为了控制某些共享资源（数据库或文件）的访问权限
   - 通过单例模式多次创建的对象永远只有最开始的那一个
2. 为这个单一实例提供了一个全局访问节点
   - 与全局变量一样，在程序的任何地方都可以访问特定对象，且保证这个实例不被覆盖
   - 将解决一个问题的代码放在一个类中

为了解决这两个问题：

1. 将默认构造函数设为私有，防止其他对象使用单例类的new运算符
2. 新建一个静态构建方法作为构造函数，该函数会调用私有构造函数来创建对象，并保存在一个静态成员变量中，之后所有对该函数的调用都会返回这个缓存的对象。

## 深入单例模式结构

![单例模式结构](https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh.png)

## 适用场景

为了更加严格地控制全局变量，通过单例模式可以做到，它们的不同点在于，单例模式保证了类只有一个实例，除了单例类自己外无法通过任何方式替换缓存的实例。

一个实例只是单例模式默认的，当然你可以调整设定生成单例实例的数量。

## 优缺点

**优点：**

1. 保证一个类只有一个实例
2. 获得了一个指向该实例的全局访问节点
3. 仅在首次请求单例对象时对其进行初始化

**缺点：** 

1. 违反了单一职责原则
2. 可能掩盖不良设计，E.g.：程序各组件之间相互了解过多
3. 在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象
4. 客户端但单元测试会比较困难，许多测试框架都是基于继承的方式创建模拟对象，由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，需要拟定一个模拟单例方法的方案，因为不能写测试代码。