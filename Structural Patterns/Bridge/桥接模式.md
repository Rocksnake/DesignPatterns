# 桥接设计模式

Reference：https://refactoringguru.cn/design-patterns/bridge

> 将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，在开发的时候分别使用

## 实际情景对应

**场景：** 有一个形状（Shape）类，扩展两个子类，圆形和方形，这个层次结构进行扩展使得包含颜色。

**现状：** 创建了两个颜色子类，红色和蓝色。但是由于形状的类是已经有的，所以，为了得到所有不同颜色切形状不同的对象。

**问题：** 在层次结构中新增形状和颜色将导致代码复杂程度指数增长。

## 解决方案-桥接模式

首先深入分析下，问题的根本原因在哪，我们的目的是要扩展形状类，但是为了包含颜色，从而创建了另一个独立维度-颜色，扩展使用继承就出现了上述问题。

这种解决方案<font color=red>将继承改为组合</font>，抽取其中一个维度并使之成为独立的类层次。

这样就可以在初始类中引入这个新层次的对象，从而得到一个类不必拥有所有的状态和行为。将一个类层次转化为多个相关的类层次，避免单个类层次的失控。

具体对应到上述场景中，就是将颜色相关的代码抽取出来创建颜色类，在形状类中添加一个指向某一颜色的引用成员变量。这样一来，形状类可以将颜色相关的工作委派给连入的颜色对象，这样的引用就成为了形状和颜色之间的桥梁。

## 抽象和实现

在最开始简述桥接模式的时候提到了抽象和实现两个独立的层次结构，这是核心。

抽象部分（也称为接口）是一些实体的高阶控制层，该层自身不完成任何具体的工作，需要将工作委派给实现部分（被称为平台）。

> 注意：这里的接口和平时我们提到的接口Interface不一样

实际的程序中，抽象部分是图形用户界面（GUI），实现部分则是底层操作系统代码（API）。GUI调用API对用户的操作做出响应。

一般，可以在两个独立的维度（方向）上扩展：

- 开发多个不同的GUI
  - 控制程序的外观，并将真实工作委派给连入的实现对象，不同的实现只要遵循相同的接口就可以互换，使用同一GUI就可以在不同的API环境下使用
- 支持多个不同的API

## 深入桥接模式的结构

![桥接设计模式](https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh.png)

- **抽象部分** （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象
- **实现部分** （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。
- **精确抽象** （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。
- **客户端** （Client）通常情况仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来

## 适用场景

### 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。

 类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。

桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。

###  如果你希望在几个独立维度上扩展一个类， 可使用该模式。

 桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。

### 如果你需要在运行时切换不同实现方法， 可使用桥接模式。

 当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。

## 优缺点

**优点：**

1. 创建与平台无关的类和程序
2. 客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息
3. 开闭原则，你可以新增抽象部分和实现部分， 且它们之间不会相互影响
4. 单一职责原则，抽象部分专注于处理高层逻辑， 实现部分处理平台细节

**缺点：** 对高内聚的类使用该模式可能会让代码更加复杂